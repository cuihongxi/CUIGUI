重复造轮子

时间:	2020年2月14日12:05:05

	此时正值新型冠状肺炎爆发时期，我也被封在家里不能外出。想想应该重新整理一下以前写的代码。
	在接触编程的这五年多的时间里，我自己重复造了很多轮子。很多人都说不要重复造轮子，要在前人的基础上继续前进。开始的时候这种说法我也认同，但是轮子造多了，就发现完全不是那么回事。原因是，当我在实践中遇到了很多问题，通过对这些问题的思考，解决了以前在计算机编程中的很多疑惑。如果没有造轮子，直接使用别人已经造好的函数，就遇不到这些问题，人家已经给你封装的很好了。
	以前造过的轮子，随着这几年编程经验的提高，感觉有很多可以改进的地方。同时也需要自己实现出来，并希望将来能用于实际工程中。这是一个反复提高的过程。

	GUI图形界面是一个很好的平台，通过对它的重构，能够把以前一直存在于脑海中的想法，实现出来。

	当然实现这些想法，首先得有基石。数据结构的最重要的基石应该是动态内存分配。所以首先实现我想要的动态内存分配。

动态内存分配：
	动态内存分配首先是在一个大内存池中可以申请，释放内存。这是最基本的功能。同时每种应用场景，应该使用不同的内存分配函数。也就是不会一次性将动态内存分配函数全部实现出来，而是通过工程中遇到的实际情况不断增加。

	第一个内存分配函数应该是一个极简内存分配函数。他的特征是在内存中申请一片大的内存，之后应用会在这片内存中再申请小内存，而这些小内存，在应用存活期间不会释放。GUI设计中经常会有一个应用窗口，窗口内有各种控件，这些控件在诞生之后不会被释放，只在窗口销毁时，一起释放。所以这种内存分配方式是很需要的。因为这种方法极为简单粗暴，把它命名为Simple_Malloc()。

2020年2月15日08:28:19

	昨晚了解了一下FreeRTOS，决定移植它的5个内存分配函数。今天看看这五个文件有没有什么需要修改的地方。

	我先简单记录一下这五个文件的作用：
heap_1，是我昨天所说的极简的功能的内存分配。只可以申请，释放的时候一起释放。
heap_2，是一次性分配和释放固定大小的内存。这个应用也很广，我之前的一个项目就用了这个功能。这个功能的特点就是速度快。
heap_3，是对原有的C库进行了封装。
heap_4，是在heap_2的基础上加入了碎片整理，同时可以申请不定大小的内存。
heap_5，是在heap_4的基础上，实现了多个物理内存，合并到一个软件内存。

2020年2月15日09:08:07

	配置了一下CubeMX发现一次只能使用一个文件。不是很好，因为有些需求根据情况的不同，可能要根据内存分配搭配的来使用各个文件的函数。
	而且单独移植要FREERTOS的配置文件，所以不是很好。还是自己写一下吧，安装它的思路，再自己优化一下。

2020年2月15日09:44:38
	
	决定只实现heap_4的功能。命名为List4_Malloc()吧。因为它是用链表实现的同时是heap4的功能。

2020年2月15日12:05:21

	将list4Str的数据中的类型设置为可变类型，也就是next只代表内存池开始位置的偏移，通过设置List4Type为u8,u16,u32来适配不同大小的内存。
申请到的内存只保存该片内存的大小。这样又可以节省一个List4Type型的数据。

2020年2月16日21:33:44

	List4Malloc实现预期目标，并测试通过
/**
 *  2020年2月15日09:51:49
 *      依据FreeRTOS的heap_4的思路实现一个内存分配
 *  2020年2月16日11:22:16：
 *      与heap_4的不同之处：
 *      ①   在于分配内存的大小，定义List4Type类型的不同，决定了list4Str的大小的不同。如果是256以内的内存池，可以定义为u8类型，
 *          如果是64k内存池，则应该定义为u16类型，4G以内的内存应该定义为u32类型。
 *      ②   块的数据结构list4Str中的变量offset是记录了下一个空闲块，相对于首地址的偏移。这样就通过定义List4Type大大减少了内存浪费。
 *      ③   链表在生成新空间插入操作时进行了排序，按照从小到大的顺序排列，可以更快的malloc内存。
 *      ④   没有内存对齐
 *  2020年2月16日17:28:11
 *      功能完成，进入测试阶段
 *  2020年2月16日21:32:38
 *      测试正常 V1.0
 * 
 */

2020年2月17日11:20:52
	移植以前写的字体和按键控件
	